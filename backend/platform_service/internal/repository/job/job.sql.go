// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: job.sql

package job

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkJobExists = `-- name: CheckJobExists :one
SELECT EXISTS(SELECT 1 FROM job.jobs WHERE id = $1)
`

func (q *Queries) CheckJobExists(ctx context.Context, db DBTX, id uuid.UUID) (bool, error) {
	row := db.QueryRow(ctx, checkJobExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO job.jobs (
    title, company_name, location, employment_type, 
    salary_from, salary_to, description, requirements, author_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, title, company_name, location, employment_type, salary_from, salary_to, description, requirements, author_id, created_at, updated_at, status
`

type CreateJobParams struct {
	Title          string
	CompanyName    string
	Location       string
	EmploymentType string
	SalaryFrom     sql.NullInt32
	SalaryTo       sql.NullInt32
	Description    string
	Requirements   string
	AuthorID       uuid.UUID
}

func (q *Queries) CreateJob(ctx context.Context, db DBTX, arg CreateJobParams) (JobJob, error) {
	row := db.QueryRow(ctx, createJob,
		arg.Title,
		arg.CompanyName,
		arg.Location,
		arg.EmploymentType,
		arg.SalaryFrom,
		arg.SalaryTo,
		arg.Description,
		arg.Requirements,
		arg.AuthorID,
	)
	var i JobJob
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CompanyName,
		&i.Location,
		&i.EmploymentType,
		&i.SalaryFrom,
		&i.SalaryTo,
		&i.Description,
		&i.Requirements,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const createJobApplication = `-- name: CreateJobApplication :one
INSERT INTO job.job_applications (job_id, applicant_id)
VALUES ($1, $2)
RETURNING id, job_id, applicant_id, applied_at, status
`

type CreateJobApplicationParams struct {
	JobID       uuid.UUID
	ApplicantID uuid.UUID
}

func (q *Queries) CreateJobApplication(ctx context.Context, db DBTX, arg CreateJobApplicationParams) (JobJobApplication, error) {
	row := db.QueryRow(ctx, createJobApplication, arg.JobID, arg.ApplicantID)
	var i JobJobApplication
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.ApplicantID,
		&i.AppliedAt,
		&i.Status,
	)
	return i, err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM job.jobs WHERE id = $1 AND author_id = $2
`

type DeleteJobParams struct {
	ID       uuid.UUID
	AuthorID uuid.UUID
}

func (q *Queries) DeleteJob(ctx context.Context, db DBTX, arg DeleteJobParams) error {
	_, err := db.Exec(ctx, deleteJob, arg.ID, arg.AuthorID)
	return err
}

const getApplicationsCount = `-- name: GetApplicationsCount :one
SELECT COUNT(*) FROM job.job_applications WHERE job_id = $1
`

func (q *Queries) GetApplicationsCount(ctx context.Context, db DBTX, jobID uuid.UUID) (int64, error) {
	row := db.QueryRow(ctx, getApplicationsCount, jobID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getJobApplication = `-- name: GetJobApplication :one
SELECT id, job_id, applicant_id, applied_at, status FROM job.job_applications 
WHERE job_id = $1 AND applicant_id = $2
`

type GetJobApplicationParams struct {
	JobID       uuid.UUID
	ApplicantID uuid.UUID
}

func (q *Queries) GetJobApplication(ctx context.Context, db DBTX, arg GetJobApplicationParams) (JobJobApplication, error) {
	row := db.QueryRow(ctx, getJobApplication, arg.JobID, arg.ApplicantID)
	var i JobJobApplication
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.ApplicantID,
		&i.AppliedAt,
		&i.Status,
	)
	return i, err
}

const getJobApplications = `-- name: GetJobApplications :many
SELECT ja.id, ja.job_id, ja.applicant_id, ja.applied_at, ja.status, p.description as applicant_description, p.email as applicant_email, p.avatar as applicant_avatar
FROM job.job_applications ja
JOIN profile.profiles p ON ja.applicant_id = p.guid
WHERE ja.job_id = $1
ORDER BY ja.applied_at DESC
LIMIT $2 OFFSET $3
`

type GetJobApplicationsParams struct {
	JobID  uuid.UUID
	Limit  int32
	Offset int32
}

type GetJobApplicationsRow struct {
	ID                   uuid.UUID
	JobID                uuid.UUID
	ApplicantID          uuid.UUID
	AppliedAt            time.Time
	Status               string
	ApplicantDescription string
	ApplicantEmail       string
	ApplicantAvatar      sql.NullString
}

func (q *Queries) GetJobApplications(ctx context.Context, db DBTX, arg GetJobApplicationsParams) ([]GetJobApplicationsRow, error) {
	rows, err := db.Query(ctx, getJobApplications, arg.JobID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobApplicationsRow
	for rows.Next() {
		var i GetJobApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.ApplicantID,
			&i.AppliedAt,
			&i.Status,
			&i.ApplicantDescription,
			&i.ApplicantEmail,
			&i.ApplicantAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, title, company_name, location, employment_type, salary_from, salary_to, description, requirements, author_id, created_at, updated_at, status FROM job.jobs WHERE id = $1
`

func (q *Queries) GetJobByID(ctx context.Context, db DBTX, id uuid.UUID) (JobJob, error) {
	row := db.QueryRow(ctx, getJobByID, id)
	var i JobJob
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CompanyName,
		&i.Location,
		&i.EmploymentType,
		&i.SalaryFrom,
		&i.SalaryTo,
		&i.Description,
		&i.Requirements,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getJobs = `-- name: GetJobs :many
SELECT id, title, company_name, location, employment_type, salary_from, salary_to, description, requirements, author_id, created_at, updated_at, status FROM job.jobs 
WHERE status = 'active'
AND (
    $1::text IS NULL OR 
    to_tsvector('russian', title || ' ' || company_name || ' ' || description) @@ plainto_tsquery('russian', $1)
)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetJobsParams struct {
	Column1 string
	Limit   int32
	Offset  int32
}

func (q *Queries) GetJobs(ctx context.Context, db DBTX, arg GetJobsParams) ([]JobJob, error) {
	rows, err := db.Query(ctx, getJobs, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobJob
	for rows.Next() {
		var i JobJob
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CompanyName,
			&i.Location,
			&i.EmploymentType,
			&i.SalaryFrom,
			&i.SalaryTo,
			&i.Description,
			&i.Requirements,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobsByAuthor = `-- name: GetJobsByAuthor :many
SELECT j.id, j.title, j.company_name, j.location, j.employment_type, j.salary_from, j.salary_to, j.description, j.requirements, j.author_id, j.created_at, j.updated_at, j.status, COUNT(ja.id) as applications_count
FROM job.jobs j
LEFT JOIN job.job_applications ja ON j.id = ja.job_id
WHERE j.author_id = $1
GROUP BY j.id
ORDER BY j.created_at DESC
LIMIT $2 OFFSET $3
`

type GetJobsByAuthorParams struct {
	AuthorID uuid.UUID
	Limit    int32
	Offset   int32
}

type GetJobsByAuthorRow struct {
	ID                uuid.UUID
	Title             string
	CompanyName       string
	Location          string
	EmploymentType    string
	SalaryFrom        sql.NullInt32
	SalaryTo          sql.NullInt32
	Description       string
	Requirements      string
	AuthorID          uuid.UUID
	CreatedAt         time.Time
	UpdatedAt         time.Time
	Status            string
	ApplicationsCount int64
}

func (q *Queries) GetJobsByAuthor(ctx context.Context, db DBTX, arg GetJobsByAuthorParams) ([]GetJobsByAuthorRow, error) {
	rows, err := db.Query(ctx, getJobsByAuthor, arg.AuthorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobsByAuthorRow
	for rows.Next() {
		var i GetJobsByAuthorRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CompanyName,
			&i.Location,
			&i.EmploymentType,
			&i.SalaryFrom,
			&i.SalaryTo,
			&i.Description,
			&i.Requirements,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.ApplicationsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJob = `-- name: UpdateJob :one
UPDATE job.jobs 
SET title = $2, company_name = $3, location = $4, employment_type = $5,
    salary_from = $6, salary_to = $7, description = $8, requirements = $9, status = $10
WHERE id = $1 AND author_id = $11
RETURNING id, title, company_name, location, employment_type, salary_from, salary_to, description, requirements, author_id, created_at, updated_at, status
`

type UpdateJobParams struct {
	ID             uuid.UUID
	Title          string
	CompanyName    string
	Location       string
	EmploymentType string
	SalaryFrom     sql.NullInt32
	SalaryTo       sql.NullInt32
	Description    string
	Requirements   string
	Status         string
	AuthorID       uuid.UUID
}

func (q *Queries) UpdateJob(ctx context.Context, db DBTX, arg UpdateJobParams) (JobJob, error) {
	row := db.QueryRow(ctx, updateJob,
		arg.ID,
		arg.Title,
		arg.CompanyName,
		arg.Location,
		arg.EmploymentType,
		arg.SalaryFrom,
		arg.SalaryTo,
		arg.Description,
		arg.Requirements,
		arg.Status,
		arg.AuthorID,
	)
	var i JobJob
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CompanyName,
		&i.Location,
		&i.EmploymentType,
		&i.SalaryFrom,
		&i.SalaryTo,
		&i.Description,
		&i.Requirements,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const updateJobApplicationStatus = `-- name: UpdateJobApplicationStatus :one
UPDATE job.job_applications 
SET status = $3
WHERE job_id = $1 AND applicant_id = $2
RETURNING id, job_id, applicant_id, applied_at, status
`

type UpdateJobApplicationStatusParams struct {
	JobID       uuid.UUID
	ApplicantID uuid.UUID
	Status      string
}

func (q *Queries) UpdateJobApplicationStatus(ctx context.Context, db DBTX, arg UpdateJobApplicationStatusParams) (JobJobApplication, error) {
	row := db.QueryRow(ctx, updateJobApplicationStatus, arg.JobID, arg.ApplicantID, arg.Status)
	var i JobJobApplication
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.ApplicantID,
		&i.AppliedAt,
		&i.Status,
	)
	return i, err
}
