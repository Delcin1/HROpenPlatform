// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: auth.sql

package auth

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createSession = `-- name: CreateSession :one
INSERT INTO auth.sessions (
    id,
    secret,
    user_guid,
    created,
    ip,
    user_agent,
    active,
    nonce
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, secret, user_guid, created, ip, user_agent, active, nonce
`

type CreateSessionParams struct {
	ID        uuid.UUID
	Secret    string
	UserGuid  uuid.UUID
	Created   time.Time
	Ip        string
	UserAgent string
	Active    sql.NullBool
	Nonce     sql.NullString
}

func (q *Queries) CreateSession(ctx context.Context, db DBTX, arg CreateSessionParams) (AuthSession, error) {
	row := db.QueryRow(ctx, createSession,
		arg.ID,
		arg.Secret,
		arg.UserGuid,
		arg.Created,
		arg.Ip,
		arg.UserAgent,
		arg.Active,
		arg.Nonce,
	)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.Secret,
		&i.UserGuid,
		&i.Created,
		&i.Ip,
		&i.UserAgent,
		&i.Active,
		&i.Nonce,
	)
	return i, err
}

const getActiveSessionByUserGUID = `-- name: GetActiveSessionByUserGUID :one
SELECT id, secret, user_guid, created, ip, user_agent, active, nonce FROM auth.sessions 
WHERE user_guid = $1 AND active = true 
ORDER BY created DESC 
LIMIT 1
`

func (q *Queries) GetActiveSessionByUserGUID(ctx context.Context, db DBTX, userGuid uuid.UUID) (AuthSession, error) {
	row := db.QueryRow(ctx, getActiveSessionByUserGUID, userGuid)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.Secret,
		&i.UserGuid,
		&i.Created,
		&i.Ip,
		&i.UserAgent,
		&i.Active,
		&i.Nonce,
	)
	return i, err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, secret, user_guid, created, ip, user_agent, active, nonce FROM auth.sessions WHERE id = $1
`

func (q *Queries) GetSessionByID(ctx context.Context, db DBTX, id uuid.UUID) (AuthSession, error) {
	row := db.QueryRow(ctx, getSessionByID, id)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.Secret,
		&i.UserGuid,
		&i.Created,
		&i.Ip,
		&i.UserAgent,
		&i.Active,
		&i.Nonce,
	)
	return i, err
}

const getSessions = `-- name: GetSessions :many
select id, secret, user_guid, created, ip, user_agent, active, nonce from auth.sessions
`

func (q *Queries) GetSessions(ctx context.Context, db DBTX) ([]AuthSession, error) {
	rows, err := db.Query(ctx, getSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuthSession
	for rows.Next() {
		var i AuthSession
		if err := rows.Scan(
			&i.ID,
			&i.Secret,
			&i.UserGuid,
			&i.Created,
			&i.Ip,
			&i.UserAgent,
			&i.Active,
			&i.Nonce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const invalidateSession = `-- name: InvalidateSession :exec
UPDATE auth.sessions SET active = false WHERE id = $1
`

func (q *Queries) InvalidateSession(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, invalidateSession, id)
	return err
}
