// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: call.sql

package call

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addParticipantToCall = `-- name: AddParticipantToCall :exec
INSERT INTO call.call_participants (call_id, user_id)
VALUES ($1, $2)
`

type AddParticipantToCallParams struct {
	CallID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) AddParticipantToCall(ctx context.Context, db DBTX, arg AddParticipantToCallParams) error {
	_, err := db.Exec(ctx, addParticipantToCall, arg.CallID, arg.UserID)
	return err
}

const addTranscript = `-- name: AddTranscript :one
INSERT INTO call.transcripts (call_id, user_id, text)
VALUES ($1, $2, $3)
RETURNING id, call_id, user_id, text, timestamp
`

type AddTranscriptParams struct {
	CallID uuid.UUID
	UserID uuid.UUID
	Text   string
}

func (q *Queries) AddTranscript(ctx context.Context, db DBTX, arg AddTranscriptParams) (CallTranscript, error) {
	row := db.QueryRow(ctx, addTranscript, arg.CallID, arg.UserID, arg.Text)
	var i CallTranscript
	err := row.Scan(
		&i.ID,
		&i.CallID,
		&i.UserID,
		&i.Text,
		&i.Timestamp,
	)
	return i, err
}

const createCall = `-- name: CreateCall :one
INSERT INTO call.calls (created_at, status)
VALUES (NOW(), 'active')
RETURNING id, created_at, ended_at, status
`

func (q *Queries) CreateCall(ctx context.Context, db DBTX) (CallCall, error) {
	row := db.QueryRow(ctx, createCall)
	var i CallCall
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.EndedAt,
		&i.Status,
	)
	return i, err
}

const endCall = `-- name: EndCall :exec
UPDATE call.calls
SET status = 'ended', ended_at = NOW()
WHERE id = $1
`

func (q *Queries) EndCall(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, endCall, id)
	return err
}

const getCallByID = `-- name: GetCallByID :one
SELECT c.id, c.created_at, c.ended_at, c.status, array_agg(cp.user_id) as participants
FROM call.calls c
JOIN call.call_participants cp ON c.id = cp.call_id
WHERE c.id = $1
GROUP BY c.id
`

type GetCallByIDRow struct {
	ID           uuid.UUID
	CreatedAt    time.Time
	EndedAt      sql.NullTime
	Status       string
	Participants interface{}
}

func (q *Queries) GetCallByID(ctx context.Context, db DBTX, id uuid.UUID) (GetCallByIDRow, error) {
	row := db.QueryRow(ctx, getCallByID, id)
	var i GetCallByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.EndedAt,
		&i.Status,
		&i.Participants,
	)
	return i, err
}

const getCallHistory = `-- name: GetCallHistory :many
SELECT c.id, c.created_at, c.ended_at, c.status, array_agg(cp.user_id) as participants
FROM call.calls c
JOIN call.call_participants cp ON c.id = cp.call_id
WHERE c.id IN (
    SELECT cp2.call_id
    FROM call.call_participants cp2
    WHERE cp2.user_id = $1
)
GROUP BY c.id
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type GetCallHistoryParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetCallHistoryRow struct {
	ID           uuid.UUID
	CreatedAt    time.Time
	EndedAt      sql.NullTime
	Status       string
	Participants interface{}
}

func (q *Queries) GetCallHistory(ctx context.Context, db DBTX, arg GetCallHistoryParams) ([]GetCallHistoryRow, error) {
	rows, err := db.Query(ctx, getCallHistory, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCallHistoryRow
	for rows.Next() {
		var i GetCallHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.EndedAt,
			&i.Status,
			&i.Participants,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCallParticipants = `-- name: GetCallParticipants :many
SELECT cp.user_id, p.description, p.avatar
FROM call.call_participants cp
JOIN profile.profiles p ON cp.user_id = p.guid
WHERE cp.call_id = $1
`

type GetCallParticipantsRow struct {
	UserID      uuid.UUID
	Description string
	Avatar      sql.NullString
}

func (q *Queries) GetCallParticipants(ctx context.Context, db DBTX, callID uuid.UUID) ([]GetCallParticipantsRow, error) {
	rows, err := db.Query(ctx, getCallParticipants, callID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCallParticipantsRow
	for rows.Next() {
		var i GetCallParticipantsRow
		if err := rows.Scan(&i.UserID, &i.Description, &i.Avatar); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCallTranscripts = `-- name: GetCallTranscripts :many
SELECT t.id, t.call_id, t.user_id, t.text, t.timestamp, p.description as user_description, p.avatar as user_avatar
FROM call.transcripts t
JOIN profile.profiles p ON t.user_id = p.guid
WHERE t.call_id = $1
ORDER BY t.timestamp ASC
`

type GetCallTranscriptsRow struct {
	ID              uuid.UUID
	CallID          uuid.UUID
	UserID          uuid.UUID
	Text            string
	Timestamp       time.Time
	UserDescription string
	UserAvatar      sql.NullString
}

func (q *Queries) GetCallTranscripts(ctx context.Context, db DBTX, callID uuid.UUID) ([]GetCallTranscriptsRow, error) {
	rows, err := db.Query(ctx, getCallTranscripts, callID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCallTranscriptsRow
	for rows.Next() {
		var i GetCallTranscriptsRow
		if err := rows.Scan(
			&i.ID,
			&i.CallID,
			&i.UserID,
			&i.Text,
			&i.Timestamp,
			&i.UserDescription,
			&i.UserAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCalls = `-- name: GetUserCalls :many
SELECT c.id, c.created_at, c.ended_at, c.status, array_agg(cp.user_id) as participants
FROM call.calls c
JOIN call.call_participants cp ON c.id = cp.call_id
WHERE c.id IN (
    SELECT cp2.call_id
    FROM call.call_participants cp2
    WHERE cp2.user_id = $1
)
GROUP BY c.id
ORDER BY c.created_at DESC
`

type GetUserCallsRow struct {
	ID           uuid.UUID
	CreatedAt    time.Time
	EndedAt      sql.NullTime
	Status       string
	Participants interface{}
}

func (q *Queries) GetUserCalls(ctx context.Context, db DBTX, userID uuid.UUID) ([]GetUserCallsRow, error) {
	rows, err := db.Query(ctx, getUserCalls, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCallsRow
	for rows.Next() {
		var i GetUserCallsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.EndedAt,
			&i.Status,
			&i.Participants,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateParticipantLeftAt = `-- name: UpdateParticipantLeftAt :exec
UPDATE call.call_participants
SET left_at = NOW()
WHERE call_id = $1 AND user_id = $2
`

type UpdateParticipantLeftAtParams struct {
	CallID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) UpdateParticipantLeftAt(ctx context.Context, db DBTX, arg UpdateParticipantLeftAtParams) error {
	_, err := db.Exec(ctx, updateParticipantLeftAt, arg.CallID, arg.UserID)
	return err
}
